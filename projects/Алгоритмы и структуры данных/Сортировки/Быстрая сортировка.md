1) Разбиение
	 - выбираем опорный элемент
	 - делим массив относительно опорного: все элементы массива, меньше опорного - слева, большие - справа
2) Запускаем процесс разбиения отдельно в левой и правой части
![[Pasted image 20240928102756.png]]

## Разбиение

1) Разбиение Ломуто
	- Опорным элементов выбирается последний элемент в рассматриваемой части массива
	- Необходимо 2 индекса:
		- i - отвечает за границу элементов меньше опорного, на старте считаем, что таких элементов нет
		- j - для просмотра массива
	- Просматриваем массив, если элемент меньше либо равен опорному, увеличиваем границу элементов меньше опорного (i) и вставляем найденный элемент перед опорным в зону меньших опорного

```
int partition(int* a, int l, int r) {  
    int pivot = r;  
  
    int i = l - 1;  
    for(int j = l; j < r; j++) {  
        if(a[j] <= a[pivot]) {  
            i++;  
  
            int temp = a[i];  
            a[i] = a[j];  
            a[j] = temp;  
        }  
    }  
  
    int temp = a[pivot];  
    a[pivot] = a[i + 1];  
    a[i + 1] = temp;  
  
    return i + 1;  
}  
  
void quicksort(int* a, int l, int r) {  
    if(l >= r) return;  
  
    int mid = partition(a, l, r);  
    quicksort(a, l, mid - 1);  
    quicksort(a, mid, r);  
}
```


2) Разбиение Хоара
	- Опорным элементом выбирается элемент в середине массива, относительно него идет разбиение
	- Необходимо 2 индекса (i в начале массива, j - в конце)
		- i - элемент больше опорного и расположен перед ним
		- j - элемент меньше опорного и расположен после него
	- Найденные элементы меняются месстами
	- Обмен происходит до тех пор, пока индексы i и j не пересекутся


```
int partition(int* a, int l, int r) {  
    int pivot = (l + r) / 2;  
  
    int i = l;  
    int j = r;  
  
    while(i < j) {  
        while(a[pivot] > a[i]) {  
            i++;  
        }  
  
        while(a[pivot] < a[j]) {  
            j--;  
        }  
  
        if(i < j) {  
            int temp = a[i];  
            a[i] = a[j];  
            a[j] = temp;  
  
            i++;  
            j--;  
        }  
    }  
  
    return j;  
}  
  
void quicksort(int* a, int l, int r) {  
    if(l >= r) return;  
  
    int mid = partition(a, l, r);  
    quicksort(a, l, mid);  
    quicksort(a, mid + 1, r);  
}
```